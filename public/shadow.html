<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - orbit controls</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #ccc;
			color: #000;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
	</div>

	<script src="./build/cannon.js"></script>

	<script type="module">
		function printEuler(euler) {
			console.log(euler._x * 180 / Math.PI, euler._y * 180 / Math.PI, euler._z * 180 / Math.PI);
		}
		// function THREE_quat2euler(quat) {
		// 	var euler = new THREE.Euler().setFromQuaternion(quat)
		// 	// console.log(euler._x * 180 / Math.PI, euler._y * 180 / Math.PI, euler._z * 180 / Math.PI)
		// 	return euler;
		// }
		function CANNON_deg2quat(...deg) {
			let rad = deg.map(v => v * Math.PI/ 180);
			var quat = new CANNON.Quaternion().setFromEuler(...rad);
			return quat;
		}

		import * as THREE from './build/three.module.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';
		const loader = new GLTFLoader();

		let scene, camera, controls, renderer;
		let world;
		var enablePhysic = false;
		var bodies = [], meshes = [];
		var syncs = [];

		initPhysic();
		init();
		animate();

		function init() {
			setScene();
			setRenderer();
			setCamera();
			setLight();
			setControls();
			setWorld();
			setGUI();
		}

		function initPhysic() {
			world = new CANNON.World();
			world.gravity.set(0, 0, -10);
		}

		function animate(millis) {
			requestAnimationFrame(animate);
			controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
			if (enablePhysic) updateVisuals();
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}

		function updateVisuals() {
			const timeStep = 1 / 60;
			world.step(timeStep);
			for (var i = 0; i !== meshes.length; i++) {
				meshes[i].position.copy(bodies[i].position);
				meshes[i].quaternion.copy(bodies[i].quaternion);
			}
			// for (var i = 0; i < syncs.length; i++) syncs[i]();
		}

		// ====================================================================> Init Function

		function setScene() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xccccc0);
			scene.fog = new THREE.FogExp2(0xcccccc, 0.001);
		}

		function setRenderer() {
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.VSMShadowMap;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', () => {
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		}

		function setCamera() {
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(50, 0, 40);
			camera.up.set(0, 0, 1);
			scene.add(camera);
			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});
		}

		function setLight() {
			const dirLight1 = new THREE.DirectionalLight(0xffffff);
			dirLight1.position.set(1, 1, 1);
			scene.add(dirLight1);

			// const dirLight2 = new THREE.DirectionalLight( 0x002288 );
			// dirLight2.position.set( - 1, - 1, - 1 );
			// scene.add( dirLight2 );

			const ambientLight = new THREE.AmbientLight(0x222222);
			scene.add(ambientLight);

			const dirLight3 = new THREE.DirectionalLight(0xfffff0, 0.4, 1);
			dirLight3.position.set(3, 12, 15);
			dirLight3.castShadow = true;
			dirLight3.shadow.camera.near = 0.1;
			dirLight3.shadow.camera.far = 500;
			dirLight3.shadow.camera.right = 32;
			dirLight3.shadow.camera.left = - 32;
			dirLight3.shadow.camera.top = 32;
			dirLight3.shadow.camera.bottom = - 32;
			dirLight3.shadow.mapSize.width = 512;
			dirLight3.shadow.mapSize.height = 512;
			dirLight3.shadow.radius = 4;
			dirLight3.shadow.bias = - 0.0005;
			scene.add(dirLight3);
		}

		function setControls() {
			controls = new OrbitControls(camera, renderer.domElement);
			// controls.listenToKeyEvents( window ); // optional
			//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

			controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
			controls.dampingFactor = 0.05;
			controls.screenSpacePanning = false;

			controls.minDistance = 1;
			controls.maxDistance = 500;
			controls.maxPolarAngle = Math.PI / 2;
		}

		function setWorld() {
			addGruond();
			addPyramid();
			addBox();
		}

		function setGUI() {
			const gui = new GUI();
			const config = { enablePhysic: false };
			const matChanger = (value) => { enablePhysic = config.enablePhysic; };
			gui.add(config, 'enablePhysic', false).onChange(matChanger);
		}

		// ====================================================================> World's Object

		function addGruond() {
			// Physic
			var groundMaterial = new CANNON.Material();
			var groundShape = new CANNON.Plane();
			var groundBody = new CANNON.Body({
				mass: 0,
				material: groundMaterial,
				quaternion: CANNON_deg2quat(15, 0, 0)
			});
			groundBody.addShape(groundShape);
			world.addBody(groundBody);
			bodies.push(groundBody);

			// Visual
			// const ground = new THREE.BoxGeometry(500, 500, 2);
			const ground = new THREE.PlaneGeometry(100, 100, 4, 4);
			const ground_material = new THREE.MeshStandardMaterial({ color: 0xccf0cc });
			const ground_mesh = new THREE.Mesh(ground, ground_material);
			ground_mesh.castShadow = true;
			ground_mesh.receiveShadow = true;
			scene.add(ground_mesh);
			meshes.push(ground_mesh);
			
			// syncs.push(() => {
			// 	ground_mesh.position.copy(groundBody.position);
			// 	ground_mesh.quaternion.copy(groundBody.quaternion);
			// });
		}

		function addPyramid() {
			var pyramidMaterial = new CANNON.Material();
			var pyramidShape = new CANNON.Cylinder(0, 1, 5, 32, 1);
			var pyramidBody = new CANNON.Body({
				mass: 50,
				material: pyramidMaterial,
				position: new CANNON.Vec3(10, 10, 40),
				quaternion: CANNON_deg2quat(0, 0, 0) // new CANNON.Quaternion(0, 0, 0, 1)
			});
			pyramidBody.addShape(pyramidShape, null, CANNON_deg2quat(-90, 0, 0));
			world.addBody(pyramidBody);
			bodies.push(pyramidBody);

			const geometry = new THREE.CylinderGeometry(0, 1, 5, 32, 1);
			const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
			const pyramid_mesh = new THREE.Mesh(geometry, material);
			pyramid_mesh.position.set(10, 10, 40);
			pyramid_mesh.castShadow = true;
			pyramid_mesh.receiveShadow = true;
			scene.add(pyramid_mesh);
			meshes.push(pyramid_mesh);

			// syncs.push(() => {
			// 	pyramid_mesh.position.copy(pyramidBody.position);
			// 	pyramid_mesh.quaternion.copy(pyramidBody.quaternion);
			// });
		}

		function addBox() {
			let size = { x: 2, y: 2, z: .1 };
			var phyMaterial = new CANNON.Material();
			var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
			var phyBody = new CANNON.Body({
				mass: 10,
				material: phyMaterial,
				position: new CANNON.Vec3(15, 10, 40),
			});
			phyBody.addShape(phyShape, null);
			world.addBody(phyBody);
			bodies.push(phyBody);

			let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
			const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
			const mesh = new THREE.Mesh(geometry, material);
			mesh.position.set(15, 10, 40);
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			scene.add(mesh);
			meshes.push(mesh);
			
			// syncs.push(() => {
			// 	mesh.position.copy(phyBody.position);
			// 	mesh.quaternion.copy(phyBody.quaternion);
			// });
		}
	</script>
</body>

</html>