<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - orbit controls</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #ccc;
			color: #000;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
	</div>

	<script src="./build/cannon.js"></script>
	<script type="module">
		import * as THREE from './build/three.module.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		const loader = new GLTFLoader();

		let scene, camera, controls, renderer;
		let world;
		var bodies = [], meshes = [];

		initPhysic();
		init();
		animate();

		function init() {
			setScene();
			setRenderer();
			setCamera();
			setLight();
			setControls();
			setWorld();
		}

		function initPhysic() {
			world = new CANNON.World();
			world.gravity.set(0, 0, -10);
		}

		function animate(millis) {
			requestAnimationFrame(animate);
			controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
			// updateVisuals();
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}

		function updateVisuals() {
			const timeStep = 1 / 60;
			world.step(timeStep);
			for (var i = 0; i !== meshes.length; i++) {
				meshes[i].position.copy(bodies[i].position);
				meshes[i].quaternion.copy(bodies[i].quaternion);
			}
		}

		// ====================================================================> Init Function

		function setScene() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xccccc0);
			scene.fog = new THREE.FogExp2(0xcccccc, 0.001);
		}

		function setRenderer() {
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.VSMShadowMap;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', () => {
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		}

		function setCamera() {
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(50, 40, 50);
			camera.up.set(0, 0, 1);
			scene.add(camera);
			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});
		}

		function setLight() {
			const dirLight1 = new THREE.DirectionalLight(0xffffff);
			dirLight1.position.set(1, 1, 1);
			scene.add(dirLight1);

			// const dirLight2 = new THREE.DirectionalLight( 0x002288 );
			// dirLight2.position.set( - 1, - 1, - 1 );
			// scene.add( dirLight2 );

			const ambientLight = new THREE.AmbientLight(0x222222);
			scene.add(ambientLight);

			const dirLight3 = new THREE.DirectionalLight(0xfffff0, 0.4, 1);
			dirLight3.position.set(3, 12, 15);
			dirLight3.castShadow = true;
			dirLight3.shadow.camera.near = 0.1;
			dirLight3.shadow.camera.far = 500;
			dirLight3.shadow.camera.right = 32;
			dirLight3.shadow.camera.left = - 32;
			dirLight3.shadow.camera.top = 32;
			dirLight3.shadow.camera.bottom = - 32;
			dirLight3.shadow.mapSize.width = 512;
			dirLight3.shadow.mapSize.height = 512;
			dirLight3.shadow.radius = 4;
			dirLight3.shadow.bias = - 0.0005;
			scene.add(dirLight3);
		}

		function setControls() {
			controls = new OrbitControls(camera, renderer.domElement);
			// controls.listenToKeyEvents( window ); // optional
			//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

			controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
			controls.dampingFactor = 0.05;
			controls.screenSpacePanning = false;

			controls.minDistance = 1;
			controls.maxDistance = 500;
			controls.maxPolarAngle = Math.PI / 2;
		}

		function setWorld() {
			addGruond();
			addPyramid();
		}

		// ====================================================================> World's Object

		function addGruond() {
			// Physic
			var groundMaterial = new CANNON.Material();
			var groundShape = new CANNON.Plane();
			var groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
			groundBody.addShape(groundShape);
			world.addBody(groundBody);
			bodies.push(groundBody);

			// Visual
			// const ground = new THREE.BoxGeometry(500, 500, 2);
			const ground = new THREE.PlaneGeometry(100, 100, 4, 4);
			const ground_material = new THREE.MeshStandardMaterial({ color: 0xccf0cc });
			const ground_mesh = new THREE.Mesh(ground, ground_material);
			// ground_mesh.rotation.x = -(Math.PI / 2);
			// ground_mesh.castShadow = true;
			// ground_mesh.receiveShadow = true;
			scene.add(ground_mesh);
			meshes.push(ground_mesh);
		}

		function addPyramid() {
			var pyramidMaterial = new CANNON.Material();
			var pyramidShape = new CANNON.Cylinder(0, 1, 2, 4, 1);
			var pyramidBody = new CANNON.Body({
				mass: 10,
				material: pyramidMaterial,
				position: new CANNON.Vec3(10, 10, 40)
			});
			pyramidBody.addShape(pyramidShape);
			world.addBody(pyramidBody);
			bodies.push(pyramidBody);

			const geometry = new THREE.CylinderGeometry(0, 1, 2, 4, 1);
			const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });

			const pyramid_mesh = new THREE.Mesh(geometry, material);
			pyramid_mesh.position.set(10, 10, 40);
			// pyramid_mesh.updateMatrix();
			// pyramid_mesh.matrixAutoUpdate = false;
			pyramid_mesh.castShadow = true;
			pyramid_mesh.receiveShadow = true;
			scene.add(pyramid_mesh);
			meshes.push(pyramid_mesh);
		}
	</script>
</body>

</html>