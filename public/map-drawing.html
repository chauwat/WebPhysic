<html>

<head>
    <style>
        .container {
            /* border: 1px dashed #CCCCCC; */
            padding: 8px;
        }

        svg {
            width: 100%;
            height: auto;
            background-color: transparent;
            border: 1px dashed #ACC;
        }

        .next-btn {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);

            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 6px 16px;
            text-align: center;
            text-decoration: none;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, .3);
        }

        .next-btn:hover::after {
            content: " ";
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: .1;
        }

        .next-btn:active::after {
            opacity: .2;
        }
    </style>
</head>

<body onload="main()">
    <button onclick="exportAndGo()" class="next-btn" id="next-btn">Next</button>

    <div class="container">
        <svg width="720" height="480" viewBox="0 0 720 480" xmlns="http://www.w3.org/2000/svg" id="paper">
        </svg>
    </div>

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.0/anime.min.js"></script> -->

    <script lang="js">
        var paper, paperViewBoxWidth;
        var button;
        var isMouseDown = false;
        var prevPoint = {};
        var lineCount = -1;
        var lineData = [];

        function main() {
            paper = document.getElementById('paper');
            paperViewBoxWidth = paper.getAttribute('width');
            paper.addEventListener('mousedown', onMouseDown);
            paper.addEventListener('mouseup', onMouseUp);
            paper.addEventListener('mousemove', onMouseMove);
            paper.addEventListener('mouseleave', onMouseUp);
            document.addEventListener('keydown', onKeyDown);

            button = document.getElementById('next-btn');
            hideNextButton();
        }

        function genSvgNode(n, v) {
            n = document.createElementNS("http://www.w3.org/2000/svg", n);
            for (var p in v) n.setAttributeNS(null, p, v[p]);
            return n;
        }

        function drawLine({ x, y }, isNew = false) {
            let lineId = `line-${isNew ? ++lineCount : lineCount}`;
            if (isNew) {
                // const newLine = genSvgNode('circle', { cx: x, cy: y, r: 1 });
                const newLine = genSvgNode('path', {
                    id: lineId,
                    stroke: 'green',
                    'stroke-width': 2,
                    fill: 'none',
                    d: `M${x} ${y}`,
                });
                paper.appendChild(newLine);
            } else {
                let line = document.getElementById(lineId);
                let d = line.getAttribute('d');
                line.setAttribute('d', d + `L${x} ${y}`);
            }
        }

        function mapPoint({ x, y }) {
            let paperRect = paper.getBoundingClientRect();
            let scale = paperRect.width / paperViewBoxWidth;
            x = Math.ceil((x - paperRect.x) / scale);
            y = Math.ceil((y - paperRect.y) / scale);
            return { x, y };
        }

        function addLine(x, y) {
            if ((Math.abs(x - prevPoint.x) + Math.abs(y - prevPoint.y)) <= 20) return;

            drawLine(mapPoint({ x, y }), !prevPoint.x);
            if (!prevPoint.x) lineData.push([{ x, y }]);
            else lineData[lineData.length - 1].push({ x, y });

            if (lineCount >= 0) showNextButton();
            prevPoint = { x, y };
        }

        function removeLine(lineId) {
            let line = document.getElementById(lineId);
            if (line) line.parentNode.removeChild(line);
        }

        function undoDrawLine() {
            console.log('[DEBUG] Undo');
            lineData.pop();
            removeLine(`line-${lineCount--}`);
            if (lineCount < 0) hideNextButton();
        }

        function hideNextButton() {
            button.style.display = 'none';
        }

        function showNextButton() {
            button.style.display = null;
        }

        // ===============================================> USER INPUT

        function onMouseDown() {
            isMouseDown = true;
        }

        function onMouseUp() {
            isMouseDown = false;
            prevPoint = {};
        }

        function onMouseMove(ev) {
            if (isMouseDown) {
                addLine(ev.clientX, ev.clientY);
            }
        }

        function onKeyDown(e) {
            // Ctrl-Z, Undo, Remove Line
            if (e.keyCode == 90 && e.ctrlKey && lineCount >= 0) {
                undoDrawLine();
            }
        }

        // ===============================================> EXPORT

        function exportAndGo() {
            if (!lineData[0]) return;
            let y_max = Math.max(...lineData[0].map(p => p.y));
            let x_min = Math.min(...lineData[0].map(p => p.x));

            for (let i = 0; i < lineData.length; i++) {
                lineData[i] = lineData[i].map(p => ({ x: p.x - x_min, y: y_max - p.y }));
                // lineData[i] = lineData[i].map(p => ({ ...p, x: p.x - x_min }));
            }

            // console.log(lineData);
            localStorage.setItem('data', JSON.stringify(lineData));
            window.location.href = '/select.html';
        }
    </script>
</body>

</html>