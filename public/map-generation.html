<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - orbit controls</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		body {
			background-color: #ccc;
			color: #000;
		}

		#physic-info {
			color: #ffffff;
			background: rgba(0, 0, 0, .3);
			position: absolute;
			bottom: 0px;
			padding: 0 5px;
		}
	</style>
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
	</div>
	<div id="physic-info">0.0 km/h</div>

	<script src="./build/cannon.js"></script>

	<script type="module">
		function printEuler(euler) {
			console.log(euler._x * 180 / Math.PI, euler._y * 180 / Math.PI, euler._z * 180 / Math.PI);
		}

		function CANNON_deg2quat(...deg) {
			let rad = deg.map(v => v * Math.PI / 180);
			var quat = new CANNON.Quaternion().setFromEuler(...rad);
			return quat;
		}

		import * as THREE from './build/three.module.js';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';
		const loader = new GLTFLoader();

		var debugInfo;

		var keysActions = {
			ArrowUp: 'boxPush',
			ArrowDown: '',
			ArrowLeft: '',
			ArrowRight: '',
			KeyW: 'ballForward',
			KeyS: 'ballBackward',
			KeyA: 'ballLeft',
			KeyD: 'ballRight'
		};
		var actions = {};

		let scene, camera, controls, renderer;
		let world;
		var enablePhysic = true;
		var bodies = [], meshes = [];
		var syncs = [];

		initPhysic();
		init();
		animate();

		function init() {
			setScene();
			setRenderer();
			setCamera();
			setLight();
			setControls();
			setWorld();
			setGUI();
		}

		function initPhysic() {
			world = new CANNON.World();
			world.gravity.set(0, -10, 0);
		}

		function animate(millis) {
			requestAnimationFrame(animate);
			if (controls) controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
			if (enablePhysic) updateVisuals();
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}

		function updateVisuals() {
			const timeStep = 1 / 60;
			world.step(timeStep);
			// for (var i = 0; i !== meshes.length; i++) {
			// 	meshes[i].position.copy(bodies[i].position);
			// 	meshes[i].quaternion.copy(bodies[i].quaternion);
			// }
			for (var i = 0; i < syncs.length; i++) syncs[i]();
		}

		// ====================================================================> Init Function

		function setScene() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xccccc0);
			scene.fog = new THREE.FogExp2(0xcccccc, 0.001);
		}

		function setRenderer() {
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.VSMShadowMap;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', () => {
				renderer.setSize(window.innerWidth, window.innerHeight);
			});
		}

		function setCamera() {
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(-40, 30, 30);
			// camera.up.set(0, 0, 1);
			scene.add(camera);
			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});
		}

		function setLight() {
			const dirLight1 = new THREE.DirectionalLight(0xffffff);
			dirLight1.position.set(1, 1, 1);
			scene.add(dirLight1);

			// const dirLight2 = new THREE.DirectionalLight( 0x002288 );
			// dirLight2.position.set( - 1, - 1, - 1 );
			// scene.add( dirLight2 );

			const ambientLight = new THREE.AmbientLight(0x222222);
			scene.add(ambientLight);

			const dirLight3 = new THREE.DirectionalLight(0xfffff0, 0.4, 1);
			dirLight3.position.set(3, 12, 15);
			dirLight3.castShadow = true;
			dirLight3.shadow.camera.near = 0.1;
			dirLight3.shadow.camera.far = 500;
			dirLight3.shadow.camera.right = 32;
			dirLight3.shadow.camera.left = - 32;
			dirLight3.shadow.camera.top = 32;
			dirLight3.shadow.camera.bottom = - 32;
			dirLight3.shadow.mapSize.width = 512;
			dirLight3.shadow.mapSize.height = 512;
			dirLight3.shadow.radius = 4;
			dirLight3.shadow.bias = - 0.0005;
			scene.add(dirLight3);
		}

		function setControls() {
			controls = new OrbitControls(camera, renderer.domElement);

			// controls.listenToKeyEvents( window ); // optional
			// controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

			controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
			controls.dampingFactor = 0.05;
			controls.screenSpacePanning = false;

			controls.minDistance = 1;
			controls.maxDistance = 500;
			controls.maxPolarAngle = Math.PI / 2;

			function keyup(e) {
				if (keysActions[e.code]) {
					actions[keysActions[e.code]] = false;
					e.preventDefault();
					e.stopPropagation();
					return false;
				}
			}

			function keydown(e) {
				if (keysActions[e.code]) {
					actions[keysActions[e.code]] = true;
					e.preventDefault();
					e.stopPropagation();
					return false;
				}
			}

			window.addEventListener('keydown', keydown);
			window.addEventListener('keyup', keyup);
		}

		function setWorld() {
			addGruond();
			addSphere();
			addPyramid();
			// addBox();
			create3DShape(loadDataPoints(), 50);
			addHitBox({ x: 0, y: 8, z: 0 }, 1);
		}

		function setGUI() {
			const gui = new GUI();
			const config = { enablePhysic: false };
			const matChanger = (value) => { enablePhysic = config.enablePhysic; };
			gui.add(config, 'enablePhysic', false).onChange(matChanger);

			debugInfo = document.getElementById('physic-info');
		}

		function loadDataPoints() {
			let _data = localStorage.getItem('data');
			if (!_data) return [];
			let data = JSON.parse(_data);
			return data || [];
		}

		// ====================================================================> World's Object

		function addGruond() {
			// Physic
			var groundMaterial = new CANNON.Material();
			var groundShape = new CANNON.Plane();
			var groundBody = new CANNON.Body({
				mass: 0,
				material: groundMaterial,
				quaternion: CANNON_deg2quat(-90, 0, 0)
			});
			groundBody.addShape(groundShape);
			world.addBody(groundBody);
			bodies.push(groundBody);

			// Visual
			// const ground = new THREE.BoxGeometry(500, 500, 2);
			const ground = new THREE.PlaneGeometry(100, 100, 4, 4);
			const ground_material = new THREE.MeshStandardMaterial({ color: 0xccf0cc });
			const ground_mesh = new THREE.Mesh(ground, ground_material);
			ground_mesh.castShadow = true;
			ground_mesh.receiveShadow = true;
			scene.add(ground_mesh);
			meshes.push(ground_mesh);

			syncs.push(() => {
				ground_mesh.position.copy(groundBody.position);
				ground_mesh.quaternion.copy(groundBody.quaternion);
			});
		}

		function addPyramid({ x, y, z } = { x: 0, y: 3, z: 10 }) {
			var pyramidMaterial = new CANNON.Material();
			var pyramidShape = new CANNON.Cylinder(0.01, 1, 5, 4, 1);
			var pyramidBody = new CANNON.Body({
				mass: 10,
				material: pyramidMaterial,
				position: new CANNON.Vec3(x, y, z),
				quaternion: CANNON_deg2quat(45, 0, 0) // new CANNON.Quaternion(0, 0, 0, 1)
			});
			pyramidBody.addShape(pyramidShape, null, CANNON_deg2quat(-90, 0, 0));
			world.addBody(pyramidBody);
			bodies.push(pyramidBody);

			const geometry = new THREE.CylinderGeometry(0.01, 1, 5, 4, 1);
			const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
			const pyramid_mesh = new THREE.Mesh(geometry, material);
			pyramid_mesh.position.set(x, y, z);
			pyramid_mesh.castShadow = true;
			pyramid_mesh.receiveShadow = true;
			scene.add(pyramid_mesh);
			meshes.push(pyramid_mesh);

			syncs.push(() => {
				pyramid_mesh.position.copy(pyramidBody.position);
				pyramid_mesh.quaternion.copy(pyramidBody.quaternion);
			});
		}

		function addBox({ x, y, z } = { x: 0, y: 8, z: 1 }) {
			let size = { x: 5, y: .2, z: 2 };
			var phyMaterial = new CANNON.Material();
			var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
			var phyBody = new CANNON.Body({
				mass: 10,
				material: phyMaterial,
				position: new CANNON.Vec3(x, y, z),
			});
			phyBody.addShape(phyShape, null);
			world.addBody(phyBody);
			bodies.push(phyBody);

			let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
			const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
			const mesh = new THREE.Mesh(geometry, material);
			mesh.position.set(x, y, z);
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			scene.add(mesh);
			meshes.push(mesh);

			syncs.push(() => {
				mesh.position.copy(phyBody.position);
				mesh.quaternion.copy(phyBody.quaternion);
				if (actions.boxPush) {
					phyBody.applyLocalForce(new CANNON.Vec3(0, 250, 0), new CANNON.Vec3(0, 0, 0));
				}
			});
		}

		function addSphere({ x, y, z } = { x: -5, y: 5, z: 6 }, r = 1) {
			var phyMaterial = new CANNON.Material();
			var phyShape = new CANNON.Sphere(r);
			var phyBody = new CANNON.Body({
				mass: 1,
				material: phyMaterial,
				position: new CANNON.Vec3(x, y, z),
			});
			phyBody.addShape(phyShape, null);
			world.addBody(phyBody);
			bodies.push(phyBody);

			let geometry = new THREE.SphereGeometry(r, 12, 12);
			const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: true });
			const mesh = new THREE.Mesh(geometry, material);
			mesh.position.set(x, y, z);
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			scene.add(mesh);
			meshes.push(mesh);

			syncs.push(() => {
				let delta = new THREE.Vector3(phyBody.position.x - mesh.position.x, phyBody.position.y - mesh.position.y, phyBody.position.z - mesh.position.z);
				camera.position.add(delta)
				controls.target.copy(phyBody.position);
				debugInfo.innerHTML = `x: ${phyBody.position.x}<br>y: ${phyBody.position.y}<br>z: ${phyBody.position.z}`
				
				mesh.position.copy(phyBody.position);
				mesh.quaternion.copy(phyBody.quaternion);
				const centerInWorldCoords = phyBody.pointToWorldFrame(new CANNON.Vec3());

				if (actions.ballForward) {
					phyBody.applyForce(new CANNON.Vec3(100, 0, 0), centerInWorldCoords);
				}
				if (actions.ballBackward) {
					phyBody.applyForce(new CANNON.Vec3(-100, 0, 0), centerInWorldCoords);
				}
				if (actions.ballLeft) {
					phyBody.applyForce(new CANNON.Vec3(0, 0, -100), centerInWorldCoords);
				}
				if (actions.ballRight) {
					phyBody.applyForce(new CANNON.Vec3(0, 0, 100), centerInWorldCoords);
				}
			});
		}

		function addHitBox({ x, y, z } = { x: 0, y: 8, z: 1 }, rad = 0, length = 1, width = 1, debug = true) {
			let size = { x: length, y: 1, z: width };
			var phyMaterial = new CANNON.Material();
			var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
			var phyBody = new CANNON.Body({
				mass: 0,
				material: phyMaterial,
				position: new CANNON.Vec3(x, y - size.y / 2, z),
				quaternion: new CANNON.Quaternion().setFromEuler(0, 0, rad)
			});
			phyBody.addShape(phyShape);
			world.addBody(phyBody);

			if (debug) {	
				let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
				const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: true });
				const mesh = new THREE.Mesh(geometry, material);
				mesh.position.set(x, y, z);
				mesh.position.copy(phyBody.position);
				mesh.quaternion.copy(phyBody.quaternion);
				mesh.castShadow = true;
				mesh.receiveShadow = true;
				scene.add(mesh);
			}
		}

		function createDebugSphere(pos, color = 0xff3366) {
			// pos is [x, y, z]
			const geometry = new THREE.SphereGeometry(2, 16, 16);
			const material = new THREE.MeshBasicMaterial({ color, wireframe: true });
			const sphere = new THREE.Mesh(geometry, material);
			sphere.position.set(...pos)
			return sphere;
		}

		function create3DShape(points, width = 10, depth = 2, color = 0xffffff, debug = false) {
			function calcLength(posA, posB) {
				return Math.sqrt(Math.pow(posA.x - posB.x, 2) + Math.pow(posA.y - posB.y, 2));
			}

			function calcRotation(posA, posB) {
				return Math.atan((posA.y - posB.y) / (posA.x - posB.x))
			}

			const group = new THREE.Group();
			let path = new THREE.ShapePath();
			for (let i = 0; i < points.length; i++) {
				let point = points[i];
				if (i == 0) path.moveTo(point.x, point.y);
				else path.lineTo(point.x, point.y);
				if (debug) group.add(createDebugSphere([point.x, point.y, 0]));

				if (i != points.length - 1) {
					let nxtPoint = points[i + 1];
					let length = calcLength(point, nxtPoint);
					let rad = calcRotation(point, nxtPoint);
					let pos = {};
					for (let key in point) {
						pos[key] = (point[key] + nxtPoint[key]) / 2;
					}
					// console.log(point, nxtPoint, calcLength(point, nxtPoint), calcRotation(point, nxtPoint));
					addHitBox(pos, rad, length, width)
				}
			}

			for (let i = points.length - 1; i >= 0; i--) {
				let point = points[i];
				if (i == 0) path.lineTo(point.x, point.y - depth);
				else path.lineTo(point.x, point.y - depth);
			}

			let simpleShapes = path.toShapes(true);
			let shape3d = new THREE.ExtrudeGeometry(simpleShapes[0], { depth: width, bevelEnabled: false });

			const material = new THREE.MeshPhongMaterial({ color, flatShading: true, wireframe: false });
			const mesh = new THREE.Mesh(shape3d, material);
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			mesh.translateZ(- width / 2);
			group.add(mesh);

			group.castShadow = true;
			group.receiveShadow = true;
			scene.add(group);
		}
	</script>
</body>

</html>