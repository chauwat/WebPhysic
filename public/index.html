<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - orbit controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #ccc;
				color: #000;
			}

			a {
				color: red;
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
		</div>

		<script src="./build/ammo.js"></script>
		<script type="module">

			import * as THREE from './build/three.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			let physicsWorld,camera, controls, scene, renderer;
			// let rigidBodies = [], tmpTrans , clock;

			// Ammojs initialization
			Ammo().then( start )

			function start(){
                // tmpTrans = new Ammo.btTransform();
                setupPhysicsWorld();
                setupGraphics();
                renderFrame();
                // createBlock();
                createCar();
            }

			function setupPhysicsWorld(){
                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -10, 0));
            }

			function setupGraphics(){
                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xbfd1e5 );

                //create camera
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 5000 );
                camera.position.set( 0, 30, 70 );
                camera.lookAt(new THREE.Vector3(0, 0, 0));

                //Add hemisphere light
                let hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.1 );
                hemiLight.color.setHSL( 0.6, 0.6, 0.6 );
                hemiLight.groundColor.setHSL( 0.1, 1, 0.4 );
                hemiLight.position.set( 0, 50, 0 );
                scene.add( hemiLight );

                //Add directional light
                let dirLight = new THREE.DirectionalLight( 0xffffff , 1);
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                let d = 50;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;

                //Setup the renderer
                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xbfd1e5 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                renderer.gammaInput = true;
                renderer.gammaOutput = true;

                renderer.shadowMap.enabled = true;
            }

			function renderFrame(){
                let deltaTime = clock.getDelta();
                updatePhysics( deltaTime );
                renderer.render( scene, camera );
                requestAnimationFrame( renderFrame );
            }

			function updatePhysics( deltaTime ){
                // Step world
                physicsWorld.stepSimulation( deltaTime, 10 );

                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );
                    }
                }

			// Threeejs initialization
			init();			//render(); // remove when using next line for animation loop (requestAnimationFrame)
			animate();

			function init() {
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				// scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 400, 200, 0 );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.listenToKeyEvents( window ); // optional

				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 0;
				controls.maxDistance = 500;

				controls.maxPolarAngle = Math.PI / 2;

				// world
				const geometry = new THREE.BoxGeometry( 10, 20, 10 );
				const material = new THREE.MeshPhongMaterial( { color: 0xff0000, flatShading: true } );
				const plane = new THREE.BoxGeometry(500, 500, 2);
				const plane_material = new THREE.MeshStandardMaterial( { color: 0x4f4929 } );
				const plane_mesh = new THREE.Mesh( plane, plane_material );
                plane_mesh.position.x = 0;
                plane_mesh.position.y = 0;
                plane_mesh.position.z = 0;
                plane_mesh.rotation.x = -(Math.PI / 2);
                scene.add( plane_mesh ); 

				// lights

				const dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( 1, 1, 1 );
				scene.add( dirLight1 );

				// const dirLight2 = new THREE.DirectionalLight( 0x002288 );
				const dirLight2 = new THREE.DirectionalLight( 0xffffff );
				dirLight2.position.set( - 1, - 1, - 1 );
				scene.add( dirLight2 );

				// const ambientLight = new THREE.AmbientLight( 0x222222 );
				const ambientLight = new THREE.AmbientLight( 0xffffff );
				scene.add( ambientLight );
				
				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}
			
			function createCar(){
                let pos = {x: 0, y: 20, z: 0};
                let radius = 2;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

				const car = new THREE.Group();
				const backWheel = new THREE.Mesh(
					new THREE.BoxBufferGeometry(20, 20, 60),
					new THREE.MeshLambertMaterial({ color: 0x372204}));
					backWheel.position.z = 10;
					backWheel.position.x = 65;
				car.add(backWheel);

				const frontWheel = new THREE.Mesh(
					new THREE.BoxBufferGeometry(2, 2, 6),
					new THREE.MeshLambertMaterial({ color: 0x372204}));
					frontWheel.position.z = 1;
				car.add(frontWheel);
				
				const bodyCar = new THREE.Mesh(
					new THREE.BoxBufferGeometry(10, 3, 5),
					new THREE.MeshLambertMaterial({ color: 0xff0000}));
					bodyCar.position.z = 1;
					bodyCar.position.x = 3.2;
					bodyCar.position.y = 1;
				car.add(bodyCar);

				const cabin = new THREE.Mesh(
					new THREE.BoxBufferGeometry(8, 5, 4.5),
					new THREE.MeshLambertMaterial({ color: 0xffffff}));
					cabin.position.x = 3.5;
					cabin.position.z = 1;
					cabin.position.y = 2.5;
				car.add(cabin);

                car.position.set(pos.x, pos.y, pos.z);
                car.castShadow = true;
                car.receiveShadow = true;
                
                scene.add(car);

                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );
                physicsWorld.addRigidBody( body );
                car.userData.physicsBody = body;
                rigidBodies.push(car);
			}

			function createTrees(){
				const tree = new THREE.Group();
				const trunk = new THREE.Mesh(
					new THREE.BoxBufferGeometry(20, 200, 60),
					new THREE.MeshLambertMaterial({ color: 0x000000}));
				tree.add(trunk);
				
				scene.add(tree);
			}
			</script>

	</body>
</html>
  