<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - orbit controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        a {
            color: #f00;
        }
    </style>
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
    </div>

    <script type="module">
        import * as THREE from './build/three.module.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
        const loader = new GLTFLoader();

        let camera, controls, scene, renderer;
        var meshes = [];

        init();
        animate();

        function init() {
            setScene();
            setRenderer();
            setCamera();
            setLight();
            setControls();
            setWorld();
        }

        function animate(millis) {
            requestAnimationFrame(animate);
            controls.update();
            render(millis);
        }

        function render(millis) {
            renderer.render(scene, camera);
        }

        // =========================================================================== //

        function setScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xccccc0);
            scene.fog = new THREE.FogExp2(0xcccccc, 0.001);
        }

        function setRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setCamera() {
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(50, 30, -50);
            scene.add(camera);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
        }

        function setLight() {
            const dirLight1 = new THREE.DirectionalLight(0xffffff);
            dirLight1.position.set(1, 1, 1);
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0x002288);
            dirLight2.position.set(- 1, - 1, - 1);
            scene.add(dirLight2);

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            const dirLight3 = new THREE.DirectionalLight(0xfffff0, 0.4, 1);
            dirLight3.position.set(3, 12, 15);
            dirLight3.castShadow = true;
            dirLight3.shadow.camera.near = 0.1;
            dirLight3.shadow.camera.far = 500;
            dirLight3.shadow.camera.right = 32;
            dirLight3.shadow.camera.left = - 32;
            dirLight3.shadow.camera.top = 32;
            dirLight3.shadow.camera.bottom = - 32;
            dirLight3.shadow.mapSize.width = 512;
            dirLight3.shadow.mapSize.height = 512;
            dirLight3.shadow.radius = 4;
            dirLight3.shadow.bias = - 0.0005;
            scene.add(dirLight3);
        }

        function setControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            // controls.listenToKeyEvents( window ); // optional
            //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = 10;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI / 2;
        }

        function setWorld() {
            const geometry = new THREE.CylinderGeometry(0, 10, 20, 4, 1);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });

            const pyramid_mesh = new THREE.Mesh(geometry, material);
            pyramid_mesh.position.set(3, 10, 3);
            pyramid_mesh.castShadow = true;
            pyramid_mesh.receiveShadow = true;
            scene.add(pyramid_mesh);

            const plane = new THREE.BoxGeometry(500, 500, 2);
            const plane_material = new THREE.MeshStandardMaterial({ color: 0xccf0cc });
            const plane_mesh = new THREE.Mesh(plane, plane_material);
            plane_mesh.position.x = pyramid_mesh.position.x;
            plane_mesh.position.y = 0;
            plane_mesh.position.z = pyramid_mesh.position.z;
            plane_mesh.rotation.x = -(Math.PI / 2);
            plane_mesh.castShadow = true;
            plane_mesh.receiveShadow = true;
            scene.add(plane_mesh);

            const points = [{ x: 0, y: 2 }, { x: 50, y: 2 }, { x: 60, y: 25 }, { x: 80, y: 2 }];
            loadPoints();
            const path_mesh = create3DShape(points, 60, 2, 0xffccaa);
            scene.add(path_mesh);
        }

        function loadPoints() {
            let data = localStorage.getItem('data');
            console.log(data);
        }

        function createSphere(pos, color = 0xff3366) {
            // pos is [x, y, z]
            const geometry = new THREE.SphereGeometry(2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color, wireframe: true });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(...pos)
            return sphere;
        }

        function create3DShape(points, width = 1, depth = 0, color = 0xffffff, debug = false) {
            const group = new THREE.Group();
            let path = new THREE.ShapePath();
            for (let i in points) {
                let point = points[i];
                if (i == 0) path.moveTo(point.x, point.y);
                else path.lineTo(point.x, point.y);
                if (debug) group.add(createSphere([point.x, point.y, 0]));
            }

            for (let i = points.length - 1; i >= 0; i--) {
                let point = points[i];
                if (i == 0) path.lineTo(point.x, point.y - depth);
                else path.lineTo(point.x, point.y - depth);
            }

            let simpleShapes = path.toShapes(true);
            let shape3d = new THREE.ExtrudeGeometry(simpleShapes[0], { depth: width, bevelEnabled: false });

            const material = new THREE.MeshPhongMaterial({ color, flatShading: true });
            const mesh = new THREE.Mesh(shape3d, material);
            mesh.translateZ(- width / 2);
            
            group.rotation.y = - Math.PI / 2
            group.add(mesh);
            return group;
        }
    </script>
</body>

</html>