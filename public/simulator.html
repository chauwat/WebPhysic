<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - orbit controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        #physic-info {
            color: #ffffff;
            background: rgba(0, 0, 0, .3);
            position: absolute;
            bottom: 0px;
            padding: 0 5px;
        }
    </style>
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - orbit controls
    </div>
    <div id="physic-info">0.0 km/h</div>

    <script src="./build/cannon.js"></script>

    <script type="module">
        function printEuler(euler) {
            console.log(euler._x * 180 / Math.PI, euler._y * 180 / Math.PI, euler._z * 180 / Math.PI);
        }

        function CANNON_deg2quat(...deg) {
            let rad = deg.map(v => v * Math.PI / 180);
            var quat = new CANNON.Quaternion().setFromEuler(...rad);
            return quat;
        }

        import * as THREE from './build/three.module.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
        import { GUI } from './jsm/libs/dat.gui.module.js';
        const loader = new GLTFLoader();

        var debugInfo;

        var keysActions = {
            ArrowUp: 'carForward',
            ArrowDown: 'carBackward',
            ArrowLeft: 'carLeft',
            ArrowRight: 'carRight',
            KeyB: 'carBrake',
            KeyW: 'ballForward',
            KeyS: 'ballBackward',
            KeyA: 'ballLeft',
            KeyD: 'ballRight',
            Space: 'switchCam'
        };
        var actions = {};

        let scene, camera, controls, renderer;
        var world, vehicle;
        var enablePhysic = true;
        var bodies = [], meshes = [];
        var syncs = [];
        var cameraView = 0;

        initPhysic();
        init();
        animate();

        function init() {
            setScene();
            setRenderer();
            setCamera();
            setLight();
            setControls();
            setWorld();
            setGUI();
        }

        function initPhysic() {
            world = new CANNON.World();
            world.gravity.set(0, -10, 0);
        }

        function animate(millis) {
            requestAnimationFrame(animate);
            if (controls) controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
            if (enablePhysic) updateVisuals();
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function updateVisuals() {
            const timeStep = 1 / 60;
            world.step(timeStep);
            // for (var i = 0; i !== meshes.length; i++) {
            // 	meshes[i].position.copy(bodies[i].position);
            // 	meshes[i].quaternion.copy(bodies[i].quaternion);
            // }
            for (var i = 0; i < syncs.length; i++) syncs[i]();
        }

        // ====================================================================> Init Function

        function setScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xccccc0);
            scene.fog = new THREE.FogExp2(0xcccccc, 0.001);
        }

        function setRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setCamera() {
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-40, 30, 30);
            // camera.up.set(0, 0, 1);
            scene.add(camera);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
        }

        function setLight() {
            const dirLight1 = new THREE.DirectionalLight(0xffffff);
            dirLight1.position.set(1, 1, 1);
            scene.add(dirLight1);

            // const dirLight2 = new THREE.DirectionalLight( 0x002288 );
            // dirLight2.position.set( - 1, - 1, - 1 );
            // scene.add( dirLight2 );

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            const dirLight3 = new THREE.DirectionalLight(0xfffff0, 0.4, 1);
            dirLight3.position.set(3, 12, 15);
            dirLight3.castShadow = true;
            dirLight3.shadow.camera.near = 0.1;
            dirLight3.shadow.camera.far = 500;
            dirLight3.shadow.camera.right = 32;
            dirLight3.shadow.camera.left = - 32;
            dirLight3.shadow.camera.top = 32;
            dirLight3.shadow.camera.bottom = - 32;
            dirLight3.shadow.mapSize.width = 512;
            dirLight3.shadow.mapSize.height = 512;
            dirLight3.shadow.radius = 4;
            dirLight3.shadow.bias = - 0.0005;
            scene.add(dirLight3);
        }

        function setControls() {
            controls = new OrbitControls(camera, renderer.domElement);

            // controls.listenToKeyEvents( window ); // optional
            // controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            controls.minDistance = 1;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI / 2;

            function keyup(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = false;
                    e.preventDefault();
                    e.stopPropagation();
                    // return false;
                }
            }

            function keydown(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = true;
                    e.preventDefault();
                    e.stopPropagation();
                    // return false;
                }

                if (actions.switchCam) {
                    const totalView = 1;
                    cameraView = ++cameraView > totalView ? 0 : cameraView;
                }
                // console.log(cameraView);
            }

            window.addEventListener('keydown', keydown);
            window.addEventListener('keyup', keyup);
        }

        function setWorld() {
            addGruond();
            // addSphere();
            // addPyramid();
            // addBox();
            create3DShape(loadDataPoints(), 50);
            addHitBox({ x: 0, y: 8, z: 0 }, 0, 1, 1, true);
            createRayCast();
        }

        function setGUI() {
            const gui = new GUI();
            const config = { enablePhysic: false };
            const matChanger = (value) => { enablePhysic = config.enablePhysic; };
            gui.add(config, 'enablePhysic', false).onChange(matChanger);

            debugInfo = document.getElementById('physic-info');
        }

        function loadDataPoints() {
            let _data = localStorage.getItem('data');
            if (!_data) return [];
            let data = JSON.parse(_data);
            return data || [];
        }

        function cameraTracking(delta, pos) {
            camera.position.add(delta)
            controls.target.copy(pos);
        }

        // ====================================================================> World's Object

        function addGruond() {
            // Physic
            var groundMaterial = new CANNON.Material();
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({
                mass: 0,
                material: groundMaterial,
                quaternion: CANNON_deg2quat(-90, 0, 0)
            });
            groundBody.addShape(groundShape);
            world.addBody(groundBody);
            bodies.push(groundBody);

            // Visual
            // const ground = new THREE.BoxGeometry(500, 500, 2);
            const ground = new THREE.PlaneGeometry(10000, 100, 4, 4);
            const ground_material = new THREE.MeshStandardMaterial({ color: 0xccf0cc });
            const ground_mesh = new THREE.Mesh(ground, ground_material);
            ground_mesh.castShadow = true;
            ground_mesh.receiveShadow = true;
            scene.add(ground_mesh);
            meshes.push(ground_mesh);

            syncs.push(() => {
                ground_mesh.position.copy(groundBody.position);
                ground_mesh.quaternion.copy(groundBody.quaternion);
            });
        }

        function addPyramid({ x, y, z } = { x: 0, y: 3, z: 10 }) {
            var pyramidMaterial = new CANNON.Material();
            var pyramidShape = new CANNON.Cylinder(0.01, 1, 5, 4, 1);
            var pyramidBody = new CANNON.Body({
                mass: 10,
                material: pyramidMaterial,
                position: new CANNON.Vec3(x, y, z),
                quaternion: CANNON_deg2quat(45, 0, 0) // new CANNON.Quaternion(0, 0, 0, 1)
            });
            pyramidBody.addShape(pyramidShape, null, CANNON_deg2quat(-90, 0, 0));
            world.addBody(pyramidBody);
            bodies.push(pyramidBody);

            const geometry = new THREE.CylinderGeometry(0.01, 1, 5, 4, 1);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
            const pyramid_mesh = new THREE.Mesh(geometry, material);
            pyramid_mesh.position.set(x, y, z);
            pyramid_mesh.castShadow = true;
            pyramid_mesh.receiveShadow = true;
            scene.add(pyramid_mesh);
            meshes.push(pyramid_mesh);

            syncs.push(() => {
                pyramid_mesh.position.copy(pyramidBody.position);
                pyramid_mesh.quaternion.copy(pyramidBody.quaternion);
            });
        }

        function addBox({ x, y, z } = { x: 0, y: 8, z: 1 }) {
            let size = { x: 5, y: .2, z: 2 };
            var phyMaterial = new CANNON.Material();
            var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
            var phyBody = new CANNON.Body({
                mass: 10,
                material: phyMaterial,
                position: new CANNON.Vec3(x, y, z),
            });
            phyBody.addShape(phyShape, null);
            world.addBody(phyBody);
            bodies.push(phyBody);

            let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            meshes.push(mesh);

            syncs.push(() => {
                mesh.position.copy(phyBody.position);
                mesh.quaternion.copy(phyBody.quaternion);
                if (actions.boxPush) {
                    phyBody.applyLocalForce(new CANNON.Vec3(0, 250, 0), new CANNON.Vec3(0, 0, 0));
                }
            });
        }

        function addSphere({ x, y, z } = { x: -5, y: 5, z: 6 }, r = 1) {
            var phyMaterial = new CANNON.Material();
            var phyShape = new CANNON.Sphere(r);
            var phyBody = new CANNON.Body({
                mass: 1,
                material: phyMaterial,
                position: new CANNON.Vec3(x, y, z),
            });
            phyBody.addShape(phyShape, null);
            world.addBody(phyBody);
            bodies.push(phyBody);

            let geometry = new THREE.SphereGeometry(r, 12, 12);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: true });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            meshes.push(mesh);

            syncs.push(() => {
                if (cameraView == 1) {
                    let delta = new THREE.Vector3(phyBody.position.x - mesh.position.x, phyBody.position.y - mesh.position.y, phyBody.position.z - mesh.position.z);
                    cameraTracking(delta, phyBody.position);
                }

                mesh.position.copy(phyBody.position);
                mesh.quaternion.copy(phyBody.quaternion);
                const centerInWorldCoords = phyBody.pointToWorldFrame(new CANNON.Vec3());
                if (actions.ballForward) {
                    phyBody.applyForce(new CANNON.Vec3(100, 0, 0), centerInWorldCoords);
                } else if (actions.ballBackward) {
                    phyBody.applyForce(new CANNON.Vec3(-100, 0, 0), centerInWorldCoords);
                }
                if (actions.ballLeft) {
                    phyBody.applyForce(new CANNON.Vec3(0, 0, -100), centerInWorldCoords);
                } else if (actions.ballRight) {
                    phyBody.applyForce(new CANNON.Vec3(0, 0, 100), centerInWorldCoords);
                }
            });
        }

        function addHitBox({ x, y, z } = { x: 0, y: 8, z: 1 }, rad = 0, length = 1, width = 1, debug = false) {
            let size = { x: length, y: 1, z: width };
            var phyMaterial = new CANNON.Material();
            var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
            var phyBody = new CANNON.Body({
                mass: 0,
                material: phyMaterial,
                position: new CANNON.Vec3(x, y - size.y / 2, z),
                quaternion: new CANNON.Quaternion().setFromEuler(0, 0, rad)
            });
            phyBody.addShape(phyShape);
            world.addBody(phyBody);

            if (debug) {
                let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
                const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: true });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.position.copy(phyBody.position);
                mesh.quaternion.copy(phyBody.quaternion);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }
        }

        function createDebugSphere(pos, color = 0xff3366) {
            // pos is [x, y, z]
            const geometry = new THREE.SphereGeometry(2, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color, wireframe: true });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(...pos)
            return sphere;
        }

        function create3DShape(points, width = 10, depth = 2, color = 0xffffff, debug = false) {
            function calcLength(posA, posB) {
                return Math.sqrt(Math.pow(posA.x - posB.x, 2) + Math.pow(posA.y - posB.y, 2));
            }

            function calcRotation(posA, posB) {
                return Math.atan((posA.y - posB.y) / (posA.x - posB.x))
            }

            const xOffset = 5;
            const group = new THREE.Group();
            let path = new THREE.ShapePath();
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                if (i == 0) path.moveTo(point.x, point.y);
                else path.lineTo(point.x, point.y);
                if (debug) group.add(createDebugSphere([point.x + xOffset, point.y, 0]));

                if (i != points.length - 1) {
                    let nxtPoint = points[i + 1];
                    let length = calcLength(point, nxtPoint);
                    let rad = calcRotation(point, nxtPoint);
                    let pos = {};
                    for (let key in point) {
                        pos[key] = (point[key] + nxtPoint[key]) / 2 + (key == 'x' ? xOffset : 0);
                    }
                    // console.log(point, nxtPoint, calcLength(point, nxtPoint), calcRotation(point, nxtPoint));
                    addHitBox(pos, rad, length, width, debug)
                }
            }

            for (let i = points.length - 1; i >= 0; i--) {
                let point = points[i];
                if (i == 0) path.lineTo(point.x, point.y - depth);
                else path.lineTo(point.x, point.y - depth);
            }

            let simpleShapes = path.toShapes(true);
            let shape3d = new THREE.ExtrudeGeometry(simpleShapes[0], { depth: width, bevelEnabled: false });
            const material = new THREE.MeshPhongMaterial({ color, flatShading: true, wireframe: false });
            const mesh = new THREE.Mesh(shape3d, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.translateZ(- width / 2);
            mesh.position.x = xOffset;
            group.add(mesh);

            group.castShadow = true;
            group.receiveShadow = true;
            scene.add(group);
        }

        function createRayCast(mass = 500) {
            const chassisSize = [10, 2, 5];
            const wheelRadius = 1;
            var options = {
                radius: wheelRadius,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 45,
                suspensionRestLength: chassisSize[1] / 2 - wheelRadius / 4,
                frictionSlip: 10,
                dampingRelaxation: 2.3,
                dampingCompression: 4.5,
                maxSuspensionForce: 200000,
                rollInfluence: 0.01,
                axleLocal: new CANNON.Vec3(0, 0, -1),
                chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
                maxSuspensionTravel: 0.25,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true
            };

            var groundMaterial = new CANNON.Material("groundMaterial");
            var wheelMaterial = new CANNON.Material("wheelMaterial");
            var wheelGroundContactMaterial = window.wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
                friction: 0.6,
                restitution: 2,
                contactEquationStiffness: 1000
            });
            world.addContactMaterial(wheelGroundContactMaterial);

            // CREATE CHASSIS PHYSICS
            var chassisShape = new CANNON.Box(new CANNON.Vec3(...chassisSize.map(x => x / 2)));
            var chassisBody = new CANNON.Body({ mass });
            chassisBody.addShape(chassisShape);
            chassisBody.position.set(40, 10, 0);
            bodies.push(chassisBody);
            world.addBody(chassisBody);

            // CREATE CHASSIS (VISUAL)
            var geometry = new THREE.BoxGeometry(...chassisSize);
            var material = new THREE.MeshLambertMaterial({ color: 0x655bf5 });
            var chassisMesh = new THREE.Mesh(geometry, material);
            chassisMesh.castShadow = true;
            chassisMesh.receiveShadow = true;
            meshes.push(chassisMesh);
            scene.add(chassisMesh);

            syncs.push(() => {
                if (cameraView == 0) {
                    debugInfo.innerHTML = `x: ${chassisBody.position.x}<br>y: ${chassisBody.position.y}<br>z: ${chassisBody.position.z}`;
                    let delta = new THREE.Vector3(chassisBody.position.x - chassisMesh.position.x, chassisBody.position.y - chassisMesh.position.y, chassisBody.position.z - chassisMesh.position.z);
                    cameraTracking(delta, chassisBody.position);
                }
                chassisMesh.position.copy(chassisBody.position);
                chassisMesh.quaternion.copy(chassisBody.quaternion);
            });

            // CREATE THE VEHICLE
            vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
                indexRightAxis: 2, // x
                indexUpAxis: 1, // y
                indexForwardAxis: 0, // z
            });

            options.chassisConnectionPointLocal.set(-chassisSize[0] / 3, 0, chassisSize[2] / 2);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(chassisSize[0] / 3, 0, chassisSize[2] / 2);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(-chassisSize[0] / 3, 0, -chassisSize[2] / 2);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(chassisSize[0] / 3, 0, -chassisSize[2] / 2);
            vehicle.addWheel(options);

            vehicle.addToWorld(world);

            var wheelBodies = [], wheelVisuals = [];
            // CREATE WHEEL-BODY
            for (var i = 0; i < vehicle.wheelInfos.length; i++) {

                var wheel = vehicle.wheelInfos[i];
                // CREATE WHEEL-BODY (VISUAL)
                geometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                material = new THREE.MeshPhongMaterial({ color: 0x000000 });
                var wheelMesh = new THREE.Mesh(geometry, material);

                wheelMesh.geometry.rotateX(Math.PI / 2);
                wheelMesh.castShadow = true;
                wheelMesh.receiveShadow = true;
                wheelVisuals.push(wheelMesh);
                scene.add(wheelMesh);

                var wheelShape = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                var wheelBody = new CANNON.Body({ mass: 100 });
                var q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
                wheelBody.addShape(wheelShape, new CANNON.Vec3(), q);
                wheelBody.collisionFilterGroup = 0;
                wheelBodies.push(wheelBody);
                // bodies.push(wheelBody);
                world.addBody(wheelBody);
            }

            syncs.push(() => {
                for (var i = 0; i < vehicle.wheelInfos.length; i++) {
                    vehicle.updateWheelTransform(i);
                    var t = vehicle.wheelInfos[i].worldTransform;
                    // update wheel physics
                    wheelBodies[i].position.copy(t.position);
                    wheelBodies[i].quaternion.copy(t.quaternion);
                    // wheel update visuals
                    wheelVisuals[i].position.copy(t.position);
                    wheelVisuals[i].quaternion.copy(t.quaternion);
                }
            })
        }

        // ===================================================================================> Car Control

        function carHandler(maxForce = 2000, maxSteerVal = 0.6, brakeForce = 1000000) {
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);

            if (actions.carForward || actions.carBackward) {

                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 0);
                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 1);
                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 2);
                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 3);
            } else {
                vehicle.applyEngineForce(0, 0);
                vehicle.applyEngineForce(0, 1);
                vehicle.applyEngineForce(0, 2);
                vehicle.applyEngineForce(0, 3);
            }

            if (actions.carLeft || actions.carRight) {
                vehicle.setSteeringValue(actions.carLeft ? maxSteerVal : -maxSteerVal, 1);
                vehicle.setSteeringValue(actions.carLeft ? maxSteerVal : -maxSteerVal, 3);
            } else {
                vehicle.setSteeringValue(0, 1);
                vehicle.setSteeringValue(0, 3);
            }

            if (actions.carBrake) {
                vehicle.setBrake(brakeForce, 0);
                vehicle.setBrake(brakeForce, 1);
                vehicle.setBrake(brakeForce, 2);
                vehicle.setBrake(brakeForce, 3);
            }
        }

        syncs.push(carHandler)
    </script>
</body>

</html>