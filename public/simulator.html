<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - orbit controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mitr">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
        integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="main.css">

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            font-family: "Mitr", sans-serif;
        }

        #physic-info {
            color: #ffffff;
            background: rgba(0, 0, 0, .3);
            position: absolute;
            bottom: 0px;
            padding: 0 5px;
            font-family: Lucida Console;
            pointer-events: none;
            user-select: none;
        }

        .label {
            color: #FFF;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, .6);
        }

        .menu {
            position: absolute;
            top: 16px;
            left: 16px;
        }

        .menu-btn {
            padding: 6px 12px;
            font-size: 16px;
            background: rgba(0, 0, 0, 0);
            border: 1px solid grey;
            border-radius: 5px;
        }

        .menu-btn:hover {
            background: rgba(0, 0, 0, .1);
        }

        .menu-btn:active {
            background: rgba(0, 0, 0, .2);
        }

        .text-center {
            text-align: center;
        }

        /* .btn {
            display: inline-block;
            text-align: center;
            border-radius: 3px;
            text-decoration: none;
            text-transform: none;
            color: black;
            padding: 2px 8px;
            background: rgba(255, 255, 255, .7);
            outline: none;
            border: 0;
            line-height: 20px;
            margin: 4px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 1);
        } */

        .abs-center {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .menu-container {
            padding: 16px 32px 32px 32px;
            background: rgba(0, 0, 0, .8);
            width: 500px;
            border-radius: 3px;
            display: none;
        }

        .menu-container h1,
        .menu-container h2 {
            color: white;
            margin: 16px 0;
        }

        .close-btn {
            position: absolute;
            right: 8px;
            top: 8px;
        }

        .popup-learn-physic {
            max-height: 95%;
            width: 70%;
            min-width: 600px;
            max-width: 1200px;
            padding: 8px;
            background: white;
            z-index: 2;
            display: none;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <div class="menu">
        <button class="menu-btn" onclick="toggleMenu()">
            <i class="fa fa-bars"></i>
        </button>
    </div>

    <!-- Game Menu -->
    <div class="menu-container abs-center text-center" id="menu-container">
        <button class="close-btn btn btn-sm btn-secondary" onclick="toggleMenu()">
            <i class="fa fa-times"></i>
        </button>

        <section>
            <h2>Menu</h2>
            <button class="btn btn-sm btn-outline-light" onclick="location.reload()">Restart Game</button>
            <a href="/map-drawing.html" class="btn btn-sm btn-outline-light">Go to Map-Drawing</a>
            <a href="/select.html" class="btn btn-sm btn-outline-light">Choose My Car</a>
        </section>

        <hr class="my-4">
        <section>
            <h4>Game Setting</h4>
            <!-- <div class="d-flex align-items-center">
                <label class="text-nowrap me-2">Camera Follow Car : </label>
                <input type="checkbox" id="checkbox-camFollow" value="true" checked>
            </div> -->
            <div class="d-flex">
                <label class="text-nowrap">Camera POV : </label>
                <span class="mx-2">30</span>
                <input style="width: 100%;" type="range" min="30" max="120" value="60"
                    oninput="updateCameraFov(this.value)">
                <span class="ms-2">120</span>
            </div>
            <div class="d-flex">
                <label class="text-nowrap">World Gravity : </label>
                <span class="mx-2">0</span>
                <input style="width: 100%;" type="range" min="0" max="30" value="9.81"
                    oninput="updateWorldGravity(this.value)">
                <span class="ms-2">30</span>
            </div>
        </section>

        <section class="mt-4">
            <h4>Advance Setting</h4>
            <div class="d-flex align-items-center mt-2">
                <label class="text-nowrap">Show / Hide Physic Info : </label>
                <button class="btn btn-sm btn-outline-light ms-2" onclick="setDisplayPhysicInfo()">Toggle</button>
            </div>

            <div class="d-flex align-items-center mt-2">
                <label class="text-nowrap">Velocity, Acceleration Display Mode : </label>
                <button class="btn btn-sm btn-outline-light ms-2"
                    onclick="toggleVecAccDisplayMode(this)">Scalar</button>
            </div>

            <div class="d-flex align-items-center mt-2">
                <label class="text-nowrap">Show / Hide Hitbox Debug : </label>
                <button class="btn btn-sm btn-outline-light ms-2" onclick="toggleDebug()">Toggle</button>
                <span class="ms-2 fst-italic">(This will reload the page)</span>
            </div>
        </section>
    </div>

    <!-- End Game -->
    <div class="abs-center popup-learn-physic shadow" id="learn-physic">
        <button class="close-btn btn btn-sm btn-outline-danger"
            onclick="document.getElementById('learn-physic').style.display = null;">
            <i class="fa fa-times"></i>
        </button>
        <h3 class="text-primary text-opacity-75 text-center">Review Physic In The Game</h3>
        <div id="carouselExampleCaptions" class="carousel slide" data-bs-ride="carousel" data-bs-interval="10000">
            <div class="carousel-indicators">
                <button type="button" data-bs-target="#carouselExampleCaptions" data-bs-slide-to="0" class="active"
                    aria-current="true" aria-label="Slide 1"></button>
                <button type="button" data-bs-target="#carouselExampleCaptions" data-bs-slide-to="1"
                    aria-label="Slide 2"></button>
                <button type="button" data-bs-target="#carouselExampleCaptions" data-bs-slide-to="2"
                    aria-label="Slide 3"></button>
                <button type="button" data-bs-target="#carouselExampleCaptions" data-bs-slide-to="3"
                    aria-label="Slide 4"></button>
            </div>
            <div class="carousel-inner">
                <div class="carousel-item active">
                    <img src="./img/static.jpg" class="d-block w-100">
                    <div class="carousel-caption d-none d-md-block">
                        <h5>Static</h5>
                        <p>Brake the Car on a slope surface</p>
                    </div>
                </div>
                <div class="carousel-item">
                    <img src="./img/circle.jpg" class="d-block w-100">
                    <div class="carousel-caption d-none d-md-block text-black">
                        <h5>Kinematic of Particle</h5>
                        <p>Turn left/right while the Car is speedy</p>
                    </div>
                </div>
                <div class="carousel-item">
                    <img src="./img/projectile.jpg" class="d-block w-100">
                    <div class="carousel-caption d-none d-md-block">
                        <h5>Projectile</h5>
                        <p>Free fall Car</p>
                    </div>
                </div>
                <div class="carousel-item">
                    <img src="./img/2law.jpg" class="d-block w-100">
                    <div class="carousel-caption d-none d-md-block text-black">
                        <h5>Newton second Law</h5>
                        <p>Speeding the Car with Engine</p>
                    </div>
                </div>
            </div>
            <button class="carousel-control-prev" type="button" data-bs-target="#carouselExampleCaptions"
                data-bs-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Previous</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#carouselExampleCaptions"
                data-bs-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Next</span>
            </button>
        </div>
    </div>

    <div id="info">
        Arrow : Up / Down / Left / Right to Control, B to Brake <br>
        SpaceBar to Lock / Unlock Camera
    </div>

    <div id="physic-info"></div>

    <!-- ================================================================================================================= JavaScript -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"
        crossorigin="anonymous"></script>
    <script src="./build/cannon.js"></script>
    <script type="module">
        // const urlSearchParams = new URLSearchParams(window.location.search);
        // const params = Object.fromEntries(urlSearchParams.entries());

        function printEuler(euler) {
            console.log(euler._x * 180 / Math.PI, euler._y * 180 / Math.PI, euler._z * 180 / Math.PI);
        }

        function CANNON_deg2quat(...deg) {
            let rad = deg.map(v => v * Math.PI / 180);
            var quat = new CANNON.Quaternion().setFromEuler(...rad);
            return quat;
        }

        function calc3D2Abs(ret) {
            let { x, y, z } = Array.isArray(ret) ? { x: ret[0], y: ret[1], z: ret[2] } : ret;
            return Math.sqrt(x * x + y * y + z * z);
        }

        import * as THREE from './build/three.module.js';
        import { OrbitControls } from './jsm/controls/OrbitControls.js';
        import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
        import { GUI } from './jsm/libs/dat.gui.module.js';
        // import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';
        const loader = new GLTFLoader();

        var debugInfo;

        var keysActions = {
            ArrowUp: 'carForward',
            ArrowDown: 'carBackward',
            ArrowLeft: 'carLeft',
            ArrowRight: 'carRight',
            KeyB: 'carBrake',
            KeyW: 'ballForward',
            KeyS: 'ballBackward',
            KeyA: 'ballLeft',
            KeyD: 'ballRight',
            Space: 'switchCam'
        };
        var actions = {};

        let scene, camera, controls, renderer, labelRenderer;
        var world, vehicle;
        var bodies = [], meshes = [];
        var syncs = [];
        var cameraView = 0;

        // ======================================================> GamePlay Global Variable

        var enablePhysic = true;
        var vec_acc_type = 0;
        var cameraFollowObject = true;
        var carDetail = {
            chassisColor: 0xfec89a,
            wheelColor: 0x000000,
            chassisSize: [8, 2, 5],
            wheelRadius: 1,
            mass: 500,
            maxForce: 2000,
            brakeForce: 200
        }
        var finishLine = { position: [], radius: 10, isPassed: false };

        // Changable In Setting
        var worldGravity = 9.81;
        var cameraFov = 60;
        var setting = {
            debug: false,
        }

        // ======================================================


        initPhysic();
        init();
        animate();

        function init() {
            loadSetting();
            setScene();
            setRenderer();
            setCamera();
            setLight();
            setControls();
            setWorld();
            setGUI();
        }

        function initPhysic() {
            world = new CANNON.World();
            world.gravity.set(0, -worldGravity, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
            if (enablePhysic) updateVisuals();
            render();
        }

        function render() {
            renderer.render(scene, camera);
            // labelRenderer.render(scene, camera);
        }

        function updateVisuals() {
            const timeStep = 1 / 60;
            world.step(timeStep);
            for (var i = 0; i < syncs.length; i++) syncs[i]();
        }

        // ====================================================================> Init Function

        function setScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbbdefb);
            // scene.fog = new THREE.FogExp2(0xcccccc, 0.001);
        }

        function setRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // labelRenderer = new CSS2DRenderer();
            // labelRenderer.setSize(window.innerWidth, window.innerHeight);
            // labelRenderer.domElement.style.position = 'absolute';
            // labelRenderer.domElement.style.top = '0px';
            // document.body.appendChild(labelRenderer.domElement);

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                // labelRenderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setCamera() {
            camera = new THREE.PerspectiveCamera(cameraFov, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-10, 8, 8);
            // camera.up.set(0, 0, 1);
            scene.add(camera);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            });
        }

        function setLight() {
            const dirLight1 = new THREE.DirectionalLight(0xffffff);
            dirLight1.position.set(1, 1, 1);
            scene.add(dirLight1);

            // const dirLight2 = new THREE.DirectionalLight( 0x002288 );
            // dirLight2.position.set( - 1, - 1, - 1 );
            // scene.add( dirLight2 );

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            const dirLight3 = new THREE.DirectionalLight(0xfffff0, 0.4, 1);
            dirLight3.position.set(3, 12, 15);
            // dirLight3.castShadow = true;
            // dirLight3.shadow.camera.near = 0.1;
            // dirLight3.shadow.camera.far = 500;
            // dirLight3.shadow.camera.right = 32;
            // dirLight3.shadow.camera.left = - 32;
            // dirLight3.shadow.camera.top = 32;
            // dirLight3.shadow.camera.bottom = - 32;
            // dirLight3.shadow.mapSize.width = 512;
            // dirLight3.shadow.mapSize.height = 512;
            // dirLight3.shadow.radius = 4;
            // dirLight3.shadow.bias = - 0.0005;
            scene.add(dirLight3);
        }

        function setControls() {
            controls = new OrbitControls(camera, renderer.domElement);

            // controls.listenToKeyEvents( window ); // optional
            // controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            controls.minDistance = 1;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI / 2;

            function keyup(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = false;
                    e.preventDefault();
                    e.stopPropagation();
                    // return false;
                }
            }

            function keydown(e) {
                if (keysActions[e.code]) {
                    actions[keysActions[e.code]] = true;
                    e.preventDefault();
                    e.stopPropagation();
                    // return false;
                }

                if (actions.switchCam) {
                    const totalView = 1;
                    cameraView = ++cameraView > totalView ? 0 : cameraView;
                }
            }

            window.addEventListener('keydown', keydown);
            window.addEventListener('keyup', keyup);
        }

        function loadSetting() {
            let _setting = localStorage.getItem('setting');
            if (!_setting) return [];
            setting = JSON.parse(_setting);
        }

        function setWorld() {
            // addSphere();
            // addHitBox({ x: 0, y: 8, z: 0 }, 0, 1, 1, true);
            addGruond();

            addBox({ x: -20, y: 15, z: -10 }, { x: 1, y: 1, z: 1 }, 10);
            addBox({ x: -10, y: 15, z: -20 }, { x: 5, y: 5, z: 5 }, 100);
            addBox({ x: -10, y: 15, z: 30 }, { x: 20, y: 20, z: 20 }, 500, 0x33113a);
            addPyramid();
            buildRoad();
            carDetail = { ...carDetail, ...loadCarDetail() };
            createRayCast(carDetail);
        }

        function setGUI() {
            // const gui = new GUI();
            // const config = { enablePhysic: false };
            // const matChanger = (value) => { enablePhysic = config.enablePhysic; };
            // gui.add(config, 'enablePhysic', false).onChange(matChanger);

            debugInfo = document.getElementById('physic-info');
        }

        function cameraTracking(delta, pos) {
            if (cameraFollowObject) camera.position.add(delta)
            controls.target.copy(pos);
        }

        function formatNumber(_v, size = 4) {
            let absV = Math.abs(_v).toFixed(2);
            // console.log(absV, absV.length - 3 > size);
            let r = `0000${absV}`.substr(absV.length - size + 1);
            if (_v >= 0) r = `+${r}`;
            else r = `-${r}`;
            return r;
        }

        function displayPhysicInfo(info) {
            const unit = { position: 'm', absVelocity: 'm/s', absAcceleration: 'm/s<sup>2</sup>', velocity: 'm/s', acceleration: 'm/s<sup>2</sup>' };
            const label = { position: 'Position', absVelocity: '|Velocity|', absAcceleration: '|Acceleration|', velocity: 'Velocity', acceleration: 'Acceleration' };

            debugInfo.innerHTML = ``;
            for (let key in info) {
                let values = info[key] || 0;
                debugInfo.innerHTML += `${label[key]}: `
                if (Array.isArray(values))
                    debugInfo.innerHTML += `${values.map(_v => ' ' + formatNumber(_v))} ${unit[key]}<br>`;
                else
                    debugInfo.innerHTML += `${formatNumber(values)} ${unit[key]}<br>`;
            }
            debugInfo.innerHTML += `Mass: ${carDetail.mass} KG, Engine-force: ${4 * carDetail.maxForce} N`;
        }

        function loadDataPoints() {
            let _data = localStorage.getItem('data');
            if (!_data) return [];
            let data = JSON.parse(_data);
            return data || [];
        }

        function buildRoad() {
            let dataPoints = loadDataPoints();
            for (let i = 0; i < dataPoints.length; i++) {
                create3DShape(dataPoints[i]);
                finishLine.position = dataPoints[i][dataPoints[i].length - 1];
            }

            // Add Finish Box
            finishLine.position = { ...finishLine.position, y: finishLine.position.y + finishLine.radius / 2, z: 0 }
            let box = createDebugSphere(Object.values(finishLine.position), 0xccccff, finishLine.radius);
            scene.add(box);
        }

        function loadCarDetail() {
            let _carDetail = localStorage.getItem('carDetail');
            if (!_carDetail) return {};
            return JSON.parse(_carDetail);
        }

        // ====================================================================> World's Object

        function addGruond() {
            // Physic
            var groundMaterial = new CANNON.Material();
            var groundShape = new CANNON.Plane();
            var groundBody = new CANNON.Body({
                mass: 0,
                material: groundMaterial,
                quaternion: CANNON_deg2quat(-90, 0, 0)
            });
            groundBody.addShape(groundShape);
            world.addBody(groundBody);

            // Visual
            // const ground = new THREE.BoxGeometry(500, 500, 2);
            const ground = new THREE.PlaneGeometry(10000, 200, 4, 4);
            const ground_material = new THREE.MeshStandardMaterial({ color: 0xccf0cc });
            const ground_mesh = new THREE.Mesh(ground, ground_material);
            ground_mesh.castShadow = true;
            ground_mesh.receiveShadow = true;
            scene.add(ground_mesh);

            syncs.push(() => {
                ground_mesh.position.copy(groundBody.position);
                ground_mesh.quaternion.copy(groundBody.quaternion);
            });
        }

        function addPyramid({ x, y, z } = { x: -20, y: 5, z: 0 }) {
            var pyramidMaterial = new CANNON.Material();
            var pyramidShape = new CANNON.Cylinder(0.01, 4, 10, 4, 1);
            var pyramidBody = new CANNON.Body({
                mass: 50,
                material: pyramidMaterial,
                position: new CANNON.Vec3(x, y, z),
                quaternion: CANNON_deg2quat(0, 0, 0) // new CANNON.Quaternion(0, 0, 0, 1)
            });
            pyramidBody.addShape(pyramidShape, null, CANNON_deg2quat(-90, 0, 0));
            world.addBody(pyramidBody);

            const geometry = new THREE.CylinderGeometry(0.01, 4, 10, 4, 1);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: false });
            const pyramid_mesh = new THREE.Mesh(geometry, material);
            pyramid_mesh.position.set(x, y, z);
            pyramid_mesh.castShadow = true;
            pyramid_mesh.receiveShadow = true;
            scene.add(pyramid_mesh);

            syncs.push(() => {
                pyramid_mesh.position.copy(pyramidBody.position);
                pyramid_mesh.quaternion.copy(pyramidBody.quaternion);
            });
        }

        function addBox({ x, y, z } = { x: -10, y: 8, z: -10 }, size = { x: 2, y: 2, z: 2 }, mass = 10, color = 0xaaaaff) {
            var phyMaterial = new CANNON.Material();
            var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
            var phyBody = new CANNON.Body({
                mass,
                material: phyMaterial,
                position: new CANNON.Vec3(x, y, z),
            });
            phyBody.addShape(phyShape, null);
            world.addBody(phyBody);

            let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const material = new THREE.MeshPhongMaterial({ color, flatShading: true, wireframe: false });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            syncs.push(() => {
                mesh.position.copy(phyBody.position);
                mesh.quaternion.copy(phyBody.quaternion);
                if (actions.boxPush) {
                    phyBody.applyLocalForce(new CANNON.Vec3(0, 250, 0), new CANNON.Vec3(0, 0, 0));
                }
            });
        }

        function addSphere({ x, y, z } = { x: -5, y: 5, z: 6 }, r = 1) {
            var phyMaterial = new CANNON.Material();
            var phyShape = new CANNON.Sphere(r);
            var phyBody = new CANNON.Body({
                mass: 5,
                material: phyMaterial,
                position: new CANNON.Vec3(x, y, z),
            });
            phyBody.addShape(phyShape, null);
            world.addBody(phyBody);

            let geometry = new THREE.SphereGeometry(r, 12, 12);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true, wireframe: true });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            syncs.push(() => {
                if (cameraView == 1) {
                    let delta = new THREE.Vector3(phyBody.position.x - mesh.position.x, phyBody.position.y - mesh.position.y, phyBody.position.z - mesh.position.z);
                    cameraTracking(delta, phyBody.position);
                }

                mesh.position.copy(phyBody.position);
                mesh.quaternion.copy(phyBody.quaternion);
                const centerInWorldCoords = phyBody.pointToWorldFrame(new CANNON.Vec3());
                if (actions.ballForward) {
                    phyBody.applyForce(new CANNON.Vec3(100, 0, 0), centerInWorldCoords);
                } else if (actions.ballBackward) {
                    phyBody.applyForce(new CANNON.Vec3(-100, 0, 0), centerInWorldCoords);
                }
                if (actions.ballLeft) {
                    phyBody.applyForce(new CANNON.Vec3(0, 0, -100), centerInWorldCoords);
                } else if (actions.ballRight) {
                    phyBody.applyForce(new CANNON.Vec3(0, 0, 100), centerInWorldCoords);
                }
            });
        }

        function genVisualBoxMesh(pos, size, rad = 0, color = 0xcccccc, debug = false) {
            let geometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const material = new THREE.MeshPhongMaterial({ color, flatShading: true, wireframe: debug });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.rotation.z = rad;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function addHitBox({ x, y, z } = { x: 0, y: 8, z: 1 }, rad = 0, length = 1, width = 1, debug = false) {
            let size = { x: length, y: 1, z: width };
            var phyMaterial = new CANNON.Material();
            var phyShape = new CANNON.Box(new CANNON.Vec3(size.x * 0.5, size.y * 0.5, size.z * 0.5));
            var phyBody = new CANNON.Body({
                mass: 0,
                material: phyMaterial,
                position: new CANNON.Vec3(x, y - size.y / 2, z),
                quaternion: new CANNON.Quaternion().setFromEuler(0, 0, rad)
            });
            phyBody.addShape(phyShape);
            world.addBody(phyBody);

            if (debug) {
                let mesh = genVisualBoxMesh({ x, y, z }, size, 0, 0xffffff, true);
                mesh.position.copy(phyBody.position);
                mesh.quaternion.copy(phyBody.quaternion);
                scene.add(mesh);
            }
        }

        function createDebugSphere(pos, color = 0xff3366, radius = 1) {
            // pos is [x, y, z]
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color, wireframe: true });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(...pos)
            return sphere;
        }

        function create3DShape(points, width = 20, depth = 2, color = 0x727272, debug = setting.debug) {
            function calcLength(posA, posB) {
                return Math.sqrt(Math.pow(posA.x - posB.x, 2) + Math.pow(posA.y - posB.y, 2));
            }
            function calcRotation(posA, posB) {
                return Math.atan((posA.y - posB.y) / (posA.x - posB.x))
            }

            const xOffset = 0;
            const group = new THREE.Group();
            let path = new THREE.ShapePath();
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                if (i == 0) path.moveTo(point.x, point.y);
                else path.lineTo(point.x, point.y);
                // if (debug) group.add(createDebugSphere([point.x + xOffset, point.y, 0]));

                // Create Physics Hitbox
                if (i != points.length - 1) {
                    let nxtPoint = points[i + 1];
                    let length = calcLength(point, nxtPoint);
                    let rad = calcRotation(point, nxtPoint);
                    let pos = {};
                    for (let key in point) pos[key] = (point[key] + nxtPoint[key]) / 2 + (key == 'x' ? xOffset : 0);
                    addHitBox(pos, rad, length, width, debug)

                    if (i % 2) {
                        // Add Road Center Line
                        let mesh = genVisualBoxMesh(pos, { x: 6, y: .1, z: .5 }, rad, 0xffcc33);
                        scene.add(mesh);
                    }
                }
            }

            for (let i = points.length - 1; i >= 0; i--) {
                let point = points[i];
                if (i == 0) path.lineTo(point.x, point.y - depth);
                else path.lineTo(point.x, point.y - depth);
            }

            // Create Visual Shape
            let simpleShapes = path.toShapes(true);
            let shape3d = new THREE.ExtrudeGeometry(simpleShapes[0], { depth: width, bevelEnabled: false });
            const material = new THREE.MeshPhongMaterial({ color, flatShading: true, wireframe: false });
            const mesh = new THREE.Mesh(shape3d, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.translateZ(- width / 2);
            mesh.position.x = xOffset;
            group.add(mesh);

            group.castShadow = true;
            group.receiveShadow = true;
            scene.add(group);
        }

        var preVelocity = [0, 0, 0];
        var preTimestamp = new Date();
        function createRayCast({ chassisColor, wheelColor, mass, chassisSize, wheelRadius }) {
            const carPosition = [20, 20, 0];
            // const chassisSize = [8, 2, 5];
            // const wheelRadius = 1;
            var options = {
                radius: wheelRadius,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 45,
                suspensionRestLength: chassisSize[1] / 2 - wheelRadius / 4,
                frictionSlip: 10,
                dampingRelaxation: 2.3,
                dampingCompression: 4.5,
                maxSuspensionForce: 200000,
                rollInfluence: 0.01,
                axleLocal: new CANNON.Vec3(0, 0, -1),
                chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
                maxSuspensionTravel: 0.25,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true
            };

            // var groundMaterial = new CANNON.Material("groundMaterial");
            // var wheelMaterial = new CANNON.Material("wheelMaterial");
            // var wheelGroundContactMaterial = window.wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
            //     friction: 0.6,
            //     restitution: 2,
            //     contactEquationStiffness: 1000
            // });
            // world.addContactMaterial(wheelGroundContactMaterial);

            // CREATE CHASSIS PHYSICS
            var chassisShape = new CANNON.Box(new CANNON.Vec3(...chassisSize.map(x => x / 2)));
            var chassisBody = new CANNON.Body({ mass });
            chassisBody.addShape(chassisShape);
            chassisBody.position.set(...carPosition);
            world.addBody(chassisBody);

            // CREATE CHASSIS (VISUAL)
            var geometry = new THREE.BoxGeometry(...chassisSize);
            var material = new THREE.MeshLambertMaterial({ color: chassisColor });
            var chassisMesh = new THREE.Mesh(geometry, material);
            chassisMesh.castShadow = true;
            chassisMesh.receiveShadow = true;
            scene.add(chassisMesh);

            syncs.push(() => {
                let dt = (new Date() - preTimestamp) / 1000;
                // Display Car's Physic Info
                if (dt > .05) {
                    let absVelocity = calc3D2Abs(chassisBody.velocity);
                    let acceleration = [];
                    for (let i = 0; i < 3; i++) acceleration[i] = (chassisBody.velocity.toArray()[i] - preVelocity[i]) / dt;
                    if (vec_acc_type) {
                        displayPhysicInfo({ position: chassisBody.position.toArray(), velocity: chassisBody.velocity.toArray(), acceleration });
                    } else {
                        displayPhysicInfo({ position: chassisBody.position.toArray(), absVelocity, absAcceleration: calc3D2Abs(acceleration) });
                    }
                    preTimestamp = new Date();
                    preVelocity = chassisBody.velocity.toArray();
                }

                // Lock Camera's View
                if (cameraView == 0) {
                    let delta = new THREE.Vector3(chassisBody.position.x - chassisMesh.position.x, chassisBody.position.y - chassisMesh.position.y, chassisBody.position.z - chassisMesh.position.z);
                    cameraTracking(delta, chassisBody.position);
                }
                chassisMesh.position.copy(chassisBody.position);
                chassisMesh.quaternion.copy(chassisBody.quaternion);
                monitorCarPosition(chassisBody.position);
            });

            // CREATE THE VEHICLE
            vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
                indexRightAxis: 2, // x
                indexUpAxis: 1, // y
                indexForwardAxis: 0, // z
            });

            options.chassisConnectionPointLocal.set(-(chassisSize[0] / 2 - wheelRadius * 1.25), 0, chassisSize[2] / 2);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set((chassisSize[0] / 2 - wheelRadius * 1.25), 0, chassisSize[2] / 2);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set(-(chassisSize[0] / 2 - wheelRadius * 1.25), 0, -chassisSize[2] / 2);
            vehicle.addWheel(options);

            options.chassisConnectionPointLocal.set((chassisSize[0] / 2 - wheelRadius * 1.25), 0, -chassisSize[2] / 2);
            vehicle.addWheel(options);

            vehicle.addToWorld(world);

            var wheelBodies = [], wheelVisuals = [];
            // CREATE WHEEL-BODY
            for (var i = 0; i < vehicle.wheelInfos.length; i++) {
                var wheel = vehicle.wheelInfos[i];
                // CREATE WHEEL-BODY (VISUAL)
                geometry = new THREE.CylinderGeometry(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                material = new THREE.MeshPhongMaterial({ color: wheelColor });
                var wheelMesh = new THREE.Mesh(geometry, material);

                wheelMesh.geometry.rotateX(Math.PI / 2);
                wheelMesh.castShadow = true;
                wheelMesh.receiveShadow = true;
                wheelVisuals.push(wheelMesh);
                scene.add(wheelMesh);

                var wheelShape = new CANNON.Cylinder(wheel.radius, wheel.radius, wheel.radius / 2, 20);
                var wheelBody = new CANNON.Body({ mass: 100 });
                var q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
                wheelBody.addShape(wheelShape, new CANNON.Vec3(), q);
                wheelBody.collisionFilterGroup = 0;
                wheelBodies.push(wheelBody);
                world.addBody(wheelBody);
            }

            // const speedDiv = document.createElement('div');
            // speedDiv.className = 'label';
            // speedDiv.textContent = 'Moon';
            // speedDiv.style.marginTop = '-1em';
            // const speedLabel = new CSS2DObject(speedDiv);
            // speedLabel.position.set(0, 3, 0);
            // chassisMesh.add(speedLabel);

            syncs.push(() => {
                for (var i = 0; i < vehicle.wheelInfos.length; i++) {
                    vehicle.updateWheelTransform(i);
                    var t = vehicle.wheelInfos[i].worldTransform;
                    // update wheel physics
                    wheelBodies[i].position.copy(t.position);
                    wheelBodies[i].quaternion.copy(t.quaternion);
                    // wheel update visuals
                    wheelVisuals[i].position.copy(t.position);
                    wheelVisuals[i].quaternion.copy(t.quaternion);
                }
            })
        }

        // ===================================================================================> Car Control / Finish Line

        function carHandler(maxForce = carDetail.maxForce, maxSteerVal = 0.6, brakeForce = carDetail.brakeForce) {
            vehicle.setBrake(0, 0);
            vehicle.setBrake(0, 1);
            vehicle.setBrake(0, 2);
            vehicle.setBrake(0, 3);

            if (actions.carForward || actions.carBackward) {

                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 0);
                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 1);
                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 2);
                vehicle.applyEngineForce(actions.carForward ? maxForce : -maxForce, 3);
            } else {
                vehicle.applyEngineForce(0, 0);
                vehicle.applyEngineForce(0, 1);
                vehicle.applyEngineForce(0, 2);
                vehicle.applyEngineForce(0, 3);
            }

            if (actions.carLeft || actions.carRight) {
                vehicle.setSteeringValue(actions.carLeft ? maxSteerVal : -maxSteerVal, 1);
                vehicle.setSteeringValue(actions.carLeft ? maxSteerVal : -maxSteerVal, 3);
            } else {
                vehicle.setSteeringValue(0, 1);
                vehicle.setSteeringValue(0, 3);
            }

            if (actions.carBrake) {
                vehicle.setBrake(brakeForce, 0);
                vehicle.setBrake(brakeForce / 8, 1);
                vehicle.setBrake(brakeForce, 2);
                vehicle.setBrake(brakeForce / 8, 3);
            }
        }

        syncs.push(carHandler);

        function monitorCarPosition(position) {
            let diff = {};
            for (let key of ['x', 'y', 'z']) diff[key] = position[key] - finishLine.position[key];
            if (Math.abs(diff.x) + Math.abs(diff.y) < finishLine.radius && !finishLine.isPassed) {
                finishLine.isPassed = true;
                cameraFollowObject = false;
                console.log('FINISH');

                document.getElementById('learn-physic').style.display = 'block';
            }
        }

        // ===================================================================================> Export (Public) Function

        window.setPhysic = function (on) {
            enablePhysic = on;
        }

        window.setDisplayPhysicInfo = function (show = debugInfo.style.display) {
            debugInfo.style.display = show ? null : 'none';
            return show;
        }

        window.setVecAccDisplayMode = function (mode = vec_acc_type + 1) {
            const max_type = 1;
            if (mode > max_type) mode = 0;
            return vec_acc_type = mode;
        }

        window.updateCameraFov = function (fov) {
            camera.fov = fov;
            camera.updateProjectionMatrix();
        }

        window.updateWorldGravity = function (g) {
            worldGravity = g;
            world.gravity.set(0, -worldGravity, 0)
        }

        window.toggleDebug = function () {
            setting.debug = !setting.debug;
            localStorage.setItem('setting', JSON.stringify(setting));
            location.reload();
        }
    </script>

    <script>
        // HTML, UI Contoller
        const menuContainer = document.getElementById('menu-container')

        function toggleMenu() {
            menuContainer.style.display = menuContainer.style.display ? null : 'block';
            setPhysic(!menuContainer.style.display);
        }

        function toggleVecAccDisplayMode(e) {
            let mode = setVecAccDisplayMode();
            e.innerHTML = `${mode ? 'Vector' : 'Scalar'}`;
        }

        window.addEventListener('keydown', (e) => {
            if (e.code == 'Escape') {
                toggleMenu();
            }
        });
    </script>
</body>

</html>